warn("check your closet")
print(if math.random(1, 100) == 1 then [[
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚£õ‚£õ‚£õ‚†ã‚†≠‚†≠‚¢§‚£≠‚£≠‚£â‚£â‚†ô‚†ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†õ‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†ü‚¢ã‚¢º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ñ‚†¶‚†å‚†ô‚†õ‚†ø‚£ø‚£∑‚†Ç‚†â‚†ô‚†ª‚¢ø‚£ø‚†ã‚†Ä‚†Ä‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†õ‚†•‚£∂‚£§‚¢É‚¢Ü‚†å‚†ô‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£≠‚£õ‚†∑‚£∂‚£Æ‚£§‚£Ä‚£Ä‚£Ä‚°Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ü‚£≠‚£¥‚†∂‚†æ‚†ø‚†ø‚£É‚£†‚£¥‚£æ‚£ø‚£∂‚£å‚†ª‚¢ø‚£ø‚£ø‚£ø‚£ª‚£ø‚£¶‚£ù‚†ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ç‚†â‚†Å‚†Ä‚¢Ä‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°è‚£º‚£ø‚¢É‚†à‚£â‚£¥‚£¶‚£π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚°ô‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚£ù‚†ª‚£ø‚£ø‚£ø‚£∑‚£Ñ‚†Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†à‚£π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚¢∞‚£ø‚°ü‚¢†‚£æ‚£ø‚£ø‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ù‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Æ‚°ô‚¢ø‚£∑‚°ô‚£Ü‚†ô‚¢ø‚£∂‚£¶‚£ê‚†ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚¢Å‚£ø‚£ø‚£ß‚£Ω‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚†õ‚†ü‚£õ‚£ª‚°ô‚¢ø‚£ø‚¢ø‚£ø‚£ø‚£ø‚¢ø‚£ø‚£ø‚£ø‚£¶‚°ô‚¢∑‚†à‚£†‚£§‚°ø‚£ø‚£ø‚£∑‚£¶‚£Ñ‚£â‚†õ‚†ø‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚°á‚£º‚£ø‚£ø‚¢´‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£á‚¢®‚°ª‚£ø‚£ß‚¢†‚°ô‚¢∑‚°ô‚¢ø‚£ø‚£ß‚¢ª‚£ø‚£ø‚£ø‚£ø‚£¶‚°Ä‚†ô‚¢ø‚°ø‚£¨‚†ª‚£ø‚£≠‚°â‚¢´‚£Ω‚£•‚£¶‚£§‚£æ‚£ø‚£ø‚£ø
‚†ø‚†ø‚†ø‚†ø‚¢∞‚£ø‚£ª‚£ø‚¢∏‚£ø‚£ø‚£ø‚¢ü‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†π‚£ø‚°å‚£∑‚£å‚†ª‚£á‚¢ª‚£¶‚°π‚††‚°ô‚£ø‚°Ü‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£æ‚£¶‚†ª‚£∂‚£Ö‚°π‚¢ø‚£ø‚£¶‚£å‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£∑‚£ø‚£ø‚†±‚£ø‚£ø‚£ß‚°Ü‚¢ò‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚°π‚£ß‚†∏‚£ø‚£∑‚£¨‚°Ä‚¢ø‚£ø‚£á‚¢≥‚£å‚†ø‚¢∏‚°∏‚£ø‚£ø‚£ø‚£Ø‚°ô‚°ª‚†∑‚£å‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚°å‚¢ø‚£ø‚£ø‚£ø‚£ø
‚£ß‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚°Å‚£ø‚°ø‚£ø‚£ø‚¢∏‚£¶‚£â‚†ª‚£ø‚£ø‚£ø‚£á‚¢±‚£å‚°Ç‚†õ‚†â‚†Å‚†Å‚†Ä‚†Ä‚¢¥‚°å‚£ø‚£ß‚£∏‚£ß‚¢π‚£ø‚¢π‚£ø‚°á‚¢ø‚£∑‚£¶‚£•‚£Ä‚¢≤‚£∂‚£∂‚£§‚£≠‚£≠‚£Ñ‚£π‚£ø‚£ø‚£ø
‚£ø‚°ß‚¢Ä‚£ø‚£ø‚£ø‚¢ø‚£ø‚°Ñ‚£ø‚°á‚†ô‚£ø‚°∏‚°ø‚¢ø‚£∑‚£Ñ‚°ô‚¢ø‚£ø‚°à‚£ø‚£ø‚£ñ‚†Ä‚¢†‚††‚£ê‚†Ä‚£º‚£ß‚¢π‚£ø‚£ø‚£ø‚°Ü‚†ø‚¢∏‚£ø‚£ß‚¢∏‚£ø‚£ü‚†ª‚£ø‚£¶‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚¢É‚°æ‚†ã‚£ø‚£ø‚£á‚¢ª‚°á‚£ø‚£ß‚¢∏‚£ú‚†É‚†ø‚†ã‚†Å‚¢ø‚£ø‚£∂‚£¨‚£É‚¢∏‚£ø‚£ø‚£∑‚£§‚£§‚£¥‚£æ‚£ø‚£ø‚°ò‚£ø‚£ø‚£ø‚£∑‚¢Ä‚£ø‚¢ª‚£ø‚†Ä‚£ø‚£ø‚°Ü‚¢Ä‚†ô‚¢ß‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚†É‚†ä‚†Ä‚†Ä‚¢π‚£ø‚£ø‚°å‚°á‚¢ø‚£ø‚°à‚†ü‚†Å‚†Ä‚¢Ä‚°Ä‚†à‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á‚£ø‚†É‚¢π‚£ø‚£º‚°ø‚†à‚£ø‚†Ä‚£ø‚£ø‚£ø‚¢∏‚£∑‚£Ñ‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚°¥‚†Ç‚†Ä‚†Ä‚†ò‚£ø‚£ø‚£ß‚†ë‚£å‚¢ø‚£á‚¢†‚°Ä‚††‚†å‚†Å‚£∞‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ß‚°ü‚¢†‚°∏‚£ø‚£ø‚°á‚£∂‚¢π‚¢Ä‚°ø‚¢õ‚°ç‚†∏‚£ø‚†ø‚†ñ‚†õ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£æ‚£∂‚£ø‚†Ä‚¢ª‚£ø‚£ø‚£¶‚¢∏‚£¶‚†â‚†ò‚£ø‚£∂‚£∑‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚¢†‚£ø‚°Ö‚£ø‚£ø‚¢°‚£Æ‚°å‚£†‚£∂‚£ø‚£§‚£∂‚£∂‚£∑‚°ü‚†∏‚¢ü‚°õ‚¢õ‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚°è‚£º‚†ò‚£ø‚°ø‚£ø‚°ø‚£ø‚£∑‚°å‚¢ø‚°ü‚†ô‚†ª‚†ü‚†ª‚£ø‚£ø‚£ø‚£ø‚°ü‚°ª‚†ü‚£´‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ø‚£ø‚°á‚¢∏‚†á‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°£‚†ø‚°ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚¢É‚£ø‚†á‚¢π‚°á‚£ø‚£ø‚£ú‚¢ø‚£ø‚†ò‚†§‚†Ñ‚£Ä‚°Ä‚†Ä‚£ø‚£∑‚£≠‚£Ω‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ß‚¢∂‚£¶‚†ò‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°í‚¢†‚£æ‚£ø
‚£ø‚£ø‚°è‚†û‚£°‚£æ‚†ò‚°á‚°ò‚†ã‚†â‚°†‚¢§‚°î‚£¶‚£§‚£æ‚°ü‚£∞‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ü‚¢ª‚£æ‚£ø‚£ø‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ü‚£†‚£¥
‚£ø‚£ø‚£§‚£æ‚£ø‚°ø‚†Ä‚†Ñ‚†Å‚†Ä‚¢Ä‚°Ä‚££‚£æ‚£ø‚†ø‚¢ã‚£º‚°ø‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†°‚†Ä‚†Ä‚£π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚°ú‚¢ø‚£ø
‚£ø‚£ø‚£ø‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†â‚¢ø‚£ø‚†•‚£°‚°è‚°ü‚†Ä‚†ê‚¢∞‚£∂‚¢∂‚£∂‚£Ñ‚†Ä‚†ñ‚†Ç‚†Å‚†Ä‚†Ä‚†Ä‚†à‚†õ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚£Ø‚£Å‚¢í‚£∂‚£ø‚£ø
‚£ø‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†≤‚£Ñ‚†Å‚†Ä‚¢°‚£º‚£ø‚°á‚¢Ä‚†à‚†Ä‚†í‚¢§‚°ò‚¢ø‚£ø‚°∑‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚†Ç‚†º‚†õ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚£∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚†á‚†Ä‚°å‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚°Ñ‚†É‚¢º‚°á‚†õ‚£Å‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚°π‚¢∂‚°ô‚†Å‚£†‚¢¥‚£æ‚£π‚£ø‚°ø‚†ü‚†ã‚†Ä‚¢π‚£ø‚£ø‚£ø‚£ø‚£ø‚°ª‚£ø‚£ø‚†ã‚¢ª‚¢è‚£≠‚£ù‚°É‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚°Ü‚°Ä‚†ê‚¢Ñ‚†Ä‚†Ä‚†Ä‚°ò‚†Ä‚†Å‚†∏‚°∑‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚£º‚£ø‚£ø‚£ø‚†ã‚£æ‚°ü‚†ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†à‚¢õ‚¢ø‚£ø‚†Ä‚£å‚†õ‚¢∏‚£ß‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£Ç‚°°‚¢Ä‚¢Ä‚°Ä‚¢Å‚†Ä‚°à‚¢Ä‚°æ‚¢°‚£∂‚†∂‚£Ñ‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†•‚†à‚†Ä‚†Ä‚£†‚£ø‚£¶‚°ù‚†É‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚°î‚†Å‚†Ä‚†à‚†Ñ‚£Ç‚¢π‚†ü‚¢†‚£º‚¢±‚£ø‚£∑‚°Ö‚†Ä‚¢∞‚°ü‚£≠‚£ù‚¢É‚†Ä‚†Ä‚†Ä‚†¢‚†Ñ‚†í‚†â‚†Ä‚†Ä‚£Ä‚£¥‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚°è‚†Ä‚†á‚†Ä‚†Ä‚†∏‚†Ä‚°å‚†Ä‚†Ä‚¢à‚°†‚†ô‚†õ‚£à‚£Ñ‚°ò‚£Ø‚°ª‚°ü‚¢ª‚£ß‚°Ä‚°Ä‚†Ä‚£Ä‚£Ä‚£§‚£¥‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†ë‚¢Ñ‚°∞‚†Ç‚£Å‚†î‚†Ä‚†Ä‚¢°‚£æ‚£ø‚£ø‚£ø‚£ø‚£æ‚£∑‚¢Ä‚°õ‚¢¥‚£¶‚°ø‚¢∞‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£∑‚†Ä‚†Ä‚†à‚†â‚†Ä‚†Ä‚††‚£æ‚¢ø‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ß‚°é‚£ø‚£∂‚£∂‚£§‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£â‚£ò‚£ë‚£õ‚£ø‚£Ø‚£ø‚£ø‚¢±‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
]] else [[
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£à‚£ø‚£ø‚£ø‚£ø‚£ø‚£á‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£§‚£§‚°Ä‚†Ä‚£†‚£º‚£ø‚£ø‚£ø‚†ø‚†ø‚¢Ø‚°ø‚†ø‚¢§‚°Ä‚†Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚£ø‚£ø‚£ø‚£ø‚£æ‚£ø‚£ø‚£ø‚£ø‚°ù‚†Ä‚†Ä‚†Ä‚†à‚†∏‚†ó‚†Ω‚£º‚£ø‚£ø‚£ø‚£ø‚¢Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£¥‚£∑‚£ß‚£§‚°Ä‚¢∞‚£∑‚£ª‚£ø‚£ø‚£ø‚£ø‚°è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†â‚¢π‚£ø‚£ø‚£ø‚£ø‚£ø‚°ù‚£¥‚£ø‚£ø‚£ø‚£Ø‚£ç‚†Ä‚†à‚°å‚°ü‚†õ‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚£ø‚£ø‚£ø‚£ø‚£Ω‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†£‚£∫‚£ó‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ü‚£ù‚¢ª‚°ø‚†ü‚£ª‚°ü‚†ã‚†â‚¢ã‚°ü‚£∑‚†é‚£Ñ‚¢Å‚†ä‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£ø‚£ø‚°á‚†Ä‚°Ä‚£ø‚°ß‚†Ä‚°¥‚°æ‚†∞‚†Å‚¢ô‚£¶‚£≠‚£º‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ª‚£ø‚£ø‚£æ‚£Ñ‚£ø‚£ø‚£æ‚£Ü‚£§‚£ñ‚£†‚£æ‚°ó‚£æ‚°ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ü‚¢∞‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°†‚†§‚£†‚£∂‚£ù‚£ø‚£ø‚£ø‚£ø‚°õ‚†ë‚¢©‚£ø‚°ø‚†ì‚†õ‚†â‚£Å‚¢é‚£Æ‚£∞‚£ø‚£è‚¢∂‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£∑‚£ø‚£∂‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ì‚£ø‚£ø‚£ø‚†Ä‚†Ä‚£Ä‚£∑‚¢ø‚£ø‚£ø‚£ø‚†©‚¢ô‚£Ø‚£ó‚£é‚£≠‚£≤‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£Ø‚£Ω‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°∑‚°∂‚¢ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚£©‚†Ä‚†Ñ‚†∞‚†ç‚¢¢‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£á‚£†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£≠‚†Å‚†à‚†ô‚¢ª‚£ã‚£π‚†ê‚†Ä‚£ø‚£ø‚£ø‚£ø‚£∑‚£ñ‚†Å‚°Ä‚†Ä‚†ì‚¢£‚†Ä‚†Ä‚†Ä
‚†Ä‚£†‚†æ‚†ô‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†ø‚†Å‚†Ä‚†Ä‚†Ä‚†π‚¢Å‚†ë‚†Ä‚°ò‚°ø‚£ø‚£ø‚£ø‚£Ø‚¢Ç‚£Ñ‚°Ä‚†ò‚£≥‚°Ü‚†Ä‚†Ä
‚£º‚£∑‚£è‚£†‚£å‚£®‚£ø‚£ø‚£ø‚£ø‚°ü‚†ã‚¢†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£Æ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢£‚£à‚†Å‚¢É‚°π‚£ø‚£ø‚£ø‚£ø‚£ñ‚†é‚†Å‚†Ä‚†Å‚°∏‚°Ä‚†Ä
‚£ø‚£ø‚°ø‚£ø‚£Ø‚°ø‚¢µ‚£ø‚£ø‚£ø‚°∂‚¢Ü‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†õ‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ó‚†ë‚†à‚†Å‚°π‚£ø‚†ª‚£ø‚£ø‚£∑‚£µ‚£¶‚£§‚†ä‚†Å‚†Ä
‚†π‚£ø‚£Ø‚£Ω‚£ø‚£æ‚£∑‚°ü‚†ô‚†ª‚¢Ø‚†ã‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£æ‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†ô‚†®‚¢î‚†Ö‚£ø‚°Ä‚†à‚£ª‚£ø‚£ø‚°á‚†ë‚†´‚†ë‚°Ñ
‚†Ä‚†à‚†ª‚¢ø‚£ø‚£ø‚°ü‚†ª‚¢¶‚£§‚†É‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ã‚†ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£û‚££‚¢¥‚¢∫‚£ø‚°á‚¢†‚£ø‚£ø‚£ø‚†Ç‚†Ç‚†Ä‚†É‚¢°
‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚°ø‚¢ø‚£§‚£§‚°ú‚†Ä‚†ò‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚°ã‚°∑‚°Ç‚¢Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†Ä‚£ó‚£ø‚£ì‚£æ‚£ø‚†á‚¢∏‚£ø‚£ø‚£ø‚£ß‚††‚†Ä‚¢≤‚£∏
‚†Ä‚†Ä‚†Ä‚†à‚†ª‚¢ø‚£¶‚£ñ‚°∫‚†Å‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£µ‚†ê‚°à‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∑‚£ù‚£Ñ‚£ø‚£ø‚†Ä‚¢∏‚£ø‚£ø‚£∑‚†ä‚†Ä‚†Ä‚£¢‚°á
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°ü‚°ª‚¢π‚£ø‚†á‚†Ä‚†ò‚£ø‚£ø‚£∑‚£∑‚£•‚£Ñ‚°ø‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ω‚£ø‚£ø‚£ø‚£ø‚£´‚°ü‚†ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚¢ó‚£Ω‚£æ‚£Ø‚°Ñ‚†Ä‚¢Ä‚£æ‚†ø‚°ü‚¢ø‚¢ü‚£ã‚†Å‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ß‚£§‚£§‚£Ñ‚£†‚°§‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ø‚£ü‚¢Å‚¢∏‚†Å‚†§‚££‚°ü‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£§‚¢¶‚†ú‚£∑‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ö‚†à‚†Ä‚†®‚¢™‚¢Å‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£µ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚¢ø‚£∑‚°ü‚°†‚°∑‚†Å‚¢Ç‚†ß‚¢π‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚£ø‚£ø‚£ø‚°ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚†ø‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ß‚£ø‚£ø‚£á‚£Ω‚°á‚£†‚£æ‚¢π‚°é‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚†•‚†ì‚†ä‚†ù‚£ª‚£ø‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚°ø‚°ø‚°ø‚†ü‚¢ë‚£æ‚†Ä‚†à‚†õ‚†ì‚†ö‚†õ‚†ö‚†Å‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°ä‚¢Ä‚†Ä‚†Ä‚†ê‚£ø‚†Ä‚†Ä‚£ø‚£ø‚£ø‚°ø‚†â‚¢†‚¢Å‚°Ä‚†º‚°ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£ø‚£ø‚°ø‚¢í‚°ê‚£Ñ‚£¥‚°ø‚†Ä‚†Ä‚¢π‚£ø‚£ø‚£ø‚¢Ä‚†Ä‚†Ä‚¢Ä‚£≠‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚°ø‚¢æ‚†ø‚¢ø‚°æ‚†Å‚†Ä‚†Ä‚†à‚¢ø‚£ø‚£ø‚£ø‚†∑‚†ø‚°æ‚£æ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ω‚£ø‚£ø‚£ø‚£á‚£†‚£¥‚°é‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£æ‚°Ö‚£å‚£ø‚°Ö‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚¢è‚†â‚†â‚¢π‚¢∑‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°è‚†Å‚†Ä‚†™‚£±‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚°ø‚†ø‚†ß‚†Ä‚†Ä‚£∫‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚¢Ñ‚†Ä‚†Ñ‚†å‚°â‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚°É‚†Ä‚°Ä‚†Ä‚¢†‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ñ‚†ó‚†Ä‚¢Ä‚£∏‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢π‚£ø‚£ø‚£∑‚¢û‚°î‚†Ä‚†∫‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ß‚°Ç‚¢Ä‚†¥‚£∂‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£ø‚£ø‚†á‚†Ä‚¢†‚£É‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚°ü‚£è‚¢Ä‚£π‚°è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚†§‚£∂‚£ø‚£ø‚£ø‚£ø‚£ó‚†í‚¢ø‚£∑‚°Ñ‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£∑‚†ö‚¢≥‚£æ‚£¶‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£§‚£∂‚£æ‚£•‚°æ‚£ø‚†ü‚£´‚£æ‚£ø‚£ø‚£Ñ‚£§‚£ø‚£ø‚†Ä‚†Ä‚°º‚£æ‚£ø‚£©‚£ø‚£ø‚£∑‚£π‚£ø‚°ø‚¢Æ‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£∑‚£æ‚£Ø‚£∏‚£ø‚£ø‚°ø‚¢â‚£Ä‚¢π‚£ø‚£ø‚£ß‚£æ‚£ø‚£Ø‚£Ω‚£ø‚£ø‚£ø‚†á‚†â‚£ø‚£ß‚£¶‚£±‚°µ‚£Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°∫‚¢º‚£ø‚£ø‚£ó‚°ä‚£ò‚£π‚°õ‚¢ã‚£ø‚£ø‚£ü‚†™‚¢ª‚£ø‚£ø‚£ø‚†Ç‚†ß‚£Ω‚£ø‚£ß‚†Å‚†Ä‚£ü‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†â‚†Ä‚†â‚†â‚†õ‚†ì‚†í‚†í‚†ö‚†Å‚†à‚†õ‚†ª‚†ß‚†§‚†õ‚†õ‚†ø‚†Ø‚†ø‚†¨‚†û‚†õ‚†ª‚†≠‚†ù‚†ì‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
]])

if not game:IsLoaded() then
	game.Loaded:Wait()
end

local SCRIPT_HUB_NAME = "cooliopoolio47-hub"
local SCRIPT_HUB_GAME = "Doors"
local SCRIPT_HUB_PLACE = "Hotel"
local SCRIPT_VERSION = "0.0.9" -- please use semver (https://semver.org/)
local SCRIPT_ID = SCRIPT_HUB_NAME .. "/" .. SCRIPT_HUB_GAME .. "/" .. SCRIPT_HUB_PLACE .. " v" .. SCRIPT_VERSION

-- Services
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ProximityPromptService = game:GetService("ProximityPromptService")

-- Signal
local Signal = {}
Signal.__index = Signal
function Signal.new()
	local self = setmetatable({}, Signal)
	self.connections = {}
	return self
end
function Signal:Connect(func)
	local conn = { func = func }
	table.insert(self.connections, conn)
	return conn
end
function Signal:Disconnect(connToDisconnect)
	for i, conn in ipairs(self.connections) do
		if conn == connToDisconnect then
			table.remove(self.connections, i)
			break
		end
	end
end
function Signal:Fire(...)
	for _, conn in ipairs(self.connections) do
		task.spawn(conn.func, ...)
	end
end


-- https://github.com/deividcomsono/Obsidian/blob/main/README.md

type Obsidian = typeof(require(script:FindFirstChild("Obsidian")))
type SaveManager = typeof(require(script:FindFirstChild("SaveManager")))

local Obsidian: Obsidian = loadstring(game:HttpGet("https://raw.githubusercontent.com/deividcomsono/Obsidian/main/Library.lua"))()
local SaveManager: SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/deividcomsono/Obsidian/main/addons/SaveManager.lua"))()

local function debugNotify(text: string)
	print(SCRIPT_ID .. ": " .. text)
	Obsidian:Notify({
		Title = SCRIPT_HUB_NAME,
		Description = text,
		Time = 3,
	})
end

debugNotify("loaded libraries")

------------------------------------
-------------- COMMON --------------
------------------------------------

local Common = {
	Rooms = workspace:WaitForChild("CurrentRooms") :: Folder,
	Drops = workspace:WaitForChild("Drops"),
	RemotesFolder = ReplicatedStorage:WaitForChild("RemotesFolder") :: Folder,
	GameData = ReplicatedStorage:WaitForChild("GameData"),
	CurrentRoom = 0,
	RoomChanged = Signal.new(),
	TWEEN_INFO = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
}
function Common.GetCurrentRoomModel()
	return Common.Rooms:FindFirstChild(tostring(Common.CurrentRoom))
end

-- TweenInstance
-- fade-in/out effects for esp elements
-- TODO: optimize this
do
	-- TODO: change "out" to a better name. wtf does it do???
	-- TODO: ur mom !!!! ahhahahhah üòÇ
	function Common.TweenInstance(instance: Instance, fadeout: boolean): ()
		local function destroyInstance(): ()
			instance:Destroy()
		end

		if instance:IsA("Highlight") then
			local goal = {
				FillTransparency = if fadeout then 1 else 0.5,
				OutlineTransparency = if fadeout then 1 else 0,
			}
			if not fadeout then
				instance.FillTransparency = 1
				instance.OutlineTransparency = 1
			end

			local tween = TweenService:Create(instance, Common.TWEEN_INFO, goal)
			if fadeout then
				tween.Completed:Connect(destroyInstance)
			end
			tween:Play()
		elseif instance:IsA("BillboardGui") then
			local labels = {}
			local strokes = {}
			
			for _, child in instance:GetChildren() do
				if child:IsA("TextLabel") then
					table.insert(labels, child)
					local stroking_it = child:FindFirstChildOfClass("UIStroke")
					if stroking_it then
						table.insert(strokes, stroking_it)
					end
				end
			end
			for i, label in labels do
				local textGoal = { TextTransparency = if fadeout then 1 else 0 }
				if not fadeout then
					label.TextTransparency = 1
				end
				
				local textTween = TweenService:Create(label, Common.TWEEN_INFO, textGoal)
				if fadeout and i == #labels then
					textTween.Completed:Connect(destroyInstance)
				end
				textTween:Play()
			end
			for _, stroke in strokes do
				local strokeGoal = { Transparency = if fadeout then 1 else 0 }
				if not fadeout then
					stroke.Transparency = 1
				end
				TweenService:Create(stroke, Common.TWEEN_INFO, strokeGoal):Play()
			end
		end
	end
end

-- reusable function to create billboard guis for esp
function Common.CreateBillboardGui(options: { Parent: Instance, Adornee: BasePart, Text: string, TextColor: Color3, StudsOffset: Vector3? })
	local billboardGui = Instance.new("BillboardGui")
	billboardGui.Size = UDim2.new(0, 200, 0, 70)
	billboardGui.AlwaysOnTop = true
	billboardGui.StudsOffset = options.StudsOffset or Vector3.new(0, 0, 0)
	billboardGui.Adornee = options.Adornee

	local listLayout = Instance.new("UIListLayout")
	listLayout.Parent = billboardGui
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, 0, 0, 30)
	nameLabel.BackgroundTransparency = 1
	nameLabel.TextScaled = true
	nameLabel.Font = Enum.Font.SourceSansBold
	nameLabel.Text = options.Text
	nameLabel.TextColor3 = options.TextColor
	nameLabel.Parent = billboardGui

	local nameStroke = Instance.new("UIStroke")
	nameStroke.Color = Color3.new(0, 0, 0)
	nameStroke.Thickness = 1
	nameStroke.Parent = nameLabel

	local distanceLabel = Instance.new("TextLabel")
	distanceLabel.Size = UDim2.new(1, 0, 0, 20)
	distanceLabel.BackgroundTransparency = 1
	distanceLabel.TextScaled = true
	distanceLabel.Font = Enum.Font.SourceSans
	distanceLabel.Text = "[...]"
	distanceLabel.TextColor3 = options.TextColor
	distanceLabel.Parent = billboardGui

	local distStroke = Instance.new("UIStroke")
	distStroke.Color = Color3.new(0, 0, 0)
	distStroke.Thickness = 1
	distStroke.Parent = distanceLabel

	billboardGui.Parent = options.Parent

	return {
		gui = billboardGui,
		nameLabel = nameLabel,
		distanceLabel = distanceLabel,
	}
end

debugNotify("created Common table")


-----------------------------------
-------------- LOGIC --------------
-----------------------------------

local Logic = {}
local ActiveESPs = {}


-- Fullbright
do
	local ogBrightness, ogAmbient, roomData, roomAddedConnection, fullbrightEnabled = Lighting.Brightness, Lighting.Ambient, {}, nil, false
	local function setRoomFullbright(room)
		if room:IsA("Model") and not roomData[room] then
			local conn = room:GetAttributeChangedSignal("Ambient"):Connect(function()
				if fullbrightEnabled and room:GetAttribute("Ambient") ~= Color3.new(1, 1, 1) then
					room:SetAttribute("Ambient", Color3.new(1, 1, 1))
				end
			end)
			roomData[room] = { original = room:GetAttribute("Ambient"), connection = conn }
			room:SetAttribute("Ambient", Color3.new(1, 1, 1))
		end
	end
	Logic.Fullbright = function(enable: boolean)
		fullbrightEnabled = enable
		if enable then
			Lighting.Brightness, Lighting.Ambient = 3, Color3.new(1, 1, 1)
			for _, room in ipairs(Common.Rooms:GetChildren()) do
				setRoomFullbright(room)
			end
			roomAddedConnection = Common.Rooms.ChildAdded:Connect(setRoomFullbright)
		else
			Lighting.Brightness, Lighting.Ambient = ogBrightness, ogAmbient
			if roomAddedConnection then
				roomAddedConnection:Disconnect()
				roomAddedConnection = nil
			end
			for room, data in pairs(roomData) do
				if room and room.Parent then
					data.connection:Disconnect()
					if data.original then
						room:SetAttribute("Ambient", data.original)
					end
				end
			end
			roomData = {}
		end
	end
end

-- Door ESP
do
	local doorData, roomConn = {}, nil
	local function cleanupDoor(part)
		if doorData[part] then
			Common.TweenInstance(doorData[part].highlight, true)
			Common.TweenInstance(doorData[part].billboard, true)
			ActiveESPs[part] = nil
			doorData[part] = nil
		end
	end
	local function setupDoor(part)
		if not part or not part.Parent or not part:IsA("BasePart") or doorData[part] or not part.CanCollide then
			return
		end
		local model = part.Parent
		if not (model:IsA("Model") and model.Name == "Door") then
			return
		end
		local highlight = Instance.new("Highlight")
		highlight.Parent, highlight.FillColor, highlight.OutlineColor, highlight.DepthMode, highlight.FillTransparency = part, Color3.fromRGB(0, 255, 0), Color3.fromRGB(0, 255, 0), Enum.HighlightDepthMode.AlwaysOnTop, 0.5
		local doorText = "Door"
		local sign = model:FindFirstChild("Sign")
		if sign and sign:FindFirstChild("Stinker") and sign.Stinker:IsA("TextLabel") then
			doorText = "Door: " .. sign.Stinker.Text
		end
		local guiElements = Common.CreateBillboardGui({ Parent = part, Adornee = part, Text = doorText, TextColor = Color3.fromRGB(0, 255, 0) })
		doorData[part] = { highlight = highlight, billboard = guiElements.gui }
		ActiveESPs[part] = { adornee = part, distanceLabel = guiElements.distanceLabel }
		Common.TweenInstance(highlight, false)
		Common.TweenInstance(guiElements.gui, false)
	end
	local function updateDoors()
		for part, _ in pairs(doorData) do
			cleanupDoor(part)
		end
		for _, d in ipairs(Common.Rooms:GetDescendants()) do -- more performant search
			if d.Name == "Door" and d:IsA("BasePart") then
				local sign = d.Parent and d.Parent:FindFirstChild("Sign")
				if sign and sign:FindFirstChild("Stinker") and sign.Stinker:IsA("TextLabel") then
					local num = tonumber(sign.Stinker.Text)
					if num and (num == Common.CurrentRoom or num == Common.CurrentRoom + 1) then
						setupDoor(d)
					end
				end
			end
		end
	end
	Logic.DoorESP = function(enable: boolean)
		if enable then
			roomConn = Common.RoomChanged:Connect(updateDoors)
			updateDoors()
		else
			if roomConn then
				Common.RoomChanged:Disconnect(roomConn)
				roomConn = nil
			end
			for p, _ in pairs(doorData) do
				cleanupDoor(p)
			end
		end
	end
end

-- Monster ESP & Alerts
do
	local monsterData = {}
	local espConnection = nil
	local alertConnection = nil

	--[[
		ALERT LOGIC
		- This is controlled by the "Monster Alert" toggle.
		- It listens for specific monster models being added to the Workspace.
	]]
	local function onAlertEntityAdded(entity)
		local name = entity.Name
		if name == "RushMoving" or name == "AmbushMoving" or name == "Eyes" then
			local prettyName = string.gsub(name, "Moving", "")
			debugNotify("ALERT: " .. prettyName .. " has appeared!")
		end
	end

	Logic.SetMonsterAlert = function(enable)
		if enable then
			if not alertConnection then
				-- Check for existing entities in case the script is run mid-game
				for _, child in ipairs(Workspace:GetChildren()) do
					onAlertEntityAdded(child)
				end
				alertConnection = Workspace.ChildAdded:Connect(onAlertEntityAdded)
			end
		else
			if alertConnection then
				alertConnection:Disconnect()
				alertConnection = nil
			end
		end
	end

	--[[
		ESP LOGIC
		- This is controlled by the "Monster ESP" toggle.
		- It creates highlights and billboards for monsters.
	]]
	local function cleanupMonster(entity)
		if monsterData[entity] then
			if monsterData[entity].highlight then
				Common.TweenInstance(monsterData[entity].highlight, true)
			end
			if monsterData[entity].billboard then
				Common.TweenInstance(monsterData[entity].billboard, true)
			end
			if monsterData[entity].connection then
				monsterData[entity].connection:Disconnect()
			end
			-- Revert transparency if it was changed
			if monsterData[entity].partToMakeVisible and monsterData[entity].originalTransparency then
				monsterData[entity].partToMakeVisible.Transparency = monsterData[entity].originalTransparency
			end

			ActiveESPs[entity] = nil
			monsterData[entity] = nil
		end
	end

	local function setupMonster(entity)
		if not entity or not entity.Parent or monsterData[entity] then return end

		local monsterText, highlightPart, adorneePart, fillTransparency, partToMakeVisible, originalTransparency
		fillTransparency = 0.5 -- Default value

		if entity:IsA("BasePart") and entity.Name == "RushNew" then
			partToMakeVisible = entity
			highlightPart = entity
			adorneePart = entity
			if entity.Parent.Name == "AmbushMoving" then
				monsterText = "Ambush"
			elseif entity.Parent.Name == "RushMoving" then
				monsterText = "Rush"
			end
		elseif entity:IsA("Model") and entity.Name == "Eyes" then
			local core = entity:FindFirstChild("Core")
			if not core then return end -- Don't run if Core doesn't exist
			partToMakeVisible = core
			highlightPart = core
			adorneePart = core
			monsterText = "Eyes"
			fillTransparency = 0 -- Custom transparency for Eyes ESP
		end

		if not (monsterText and highlightPart and adorneePart) then return end

		-- Make the part visible
		originalTransparency = partToMakeVisible.Transparency
		partToMakeVisible.Transparency = 0

		-- Create ESP elements
		local highlight = Instance.new("Highlight")
		highlight.Parent, highlight.FillColor, highlight.OutlineColor, highlight.DepthMode = highlightPart, Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 0, 0), Enum.HighlightDepthMode.AlwaysOnTop
		highlight.FillTransparency = fillTransparency
		highlight.OutlineTransparency = 0

		local guiElements = Common.CreateBillboardGui({ Parent = adorneePart, Adornee = adorneePart, Text = monsterText, TextColor = Color3.fromRGB(255, 0, 0) })

		local connection = entity.AncestryChanged:Connect(function(_, parent)
			if parent == nil then cleanupMonster(entity) end
		end)

		monsterData[entity] = {
			highlight = highlight,
			billboard = guiElements.gui,
			connection = connection,
			partToMakeVisible = partToMakeVisible,
			originalTransparency = originalTransparency
		}
		ActiveESPs[entity] = { adornee = highlightPart, distanceLabel = guiElements.distanceLabel }

		-- Manually tween in to respect custom transparency
		highlight.FillTransparency, highlight.OutlineTransparency = 1, 1 -- Start transparent
		local highlightGoal = { FillTransparency = fillTransparency, OutlineTransparency = 0 }
		TweenService:Create(highlight, Common.TWEEN_INFO, highlightGoal):Play()
		Common.TweenInstance(guiElements.gui, false) -- Use helper for GUI
	end

	Logic.MonsterESP = function(enable: boolean)
		if enable then
			if not espConnection then
				for _, d in Workspace:GetDescendants() do
					if (d:IsA("BasePart") and d.Name == "RushNew") or (d:IsA("Model") and d.Name == "Eyes") then
						setupMonster(d)
					end
				end
				espConnection = Workspace.DescendantAdded:Connect(function(d)
					if (d:IsA("BasePart") and d.Name == "RushNew") or (d:IsA("Model") and d.Name == "Eyes") then
						task.wait()
						setupMonster(d)
					end
				end)
			end
		else
			if espConnection then
				espConnection:Disconnect()
				espConnection = nil
			end
			local cleanupQueue = {}
			for p, _ in pairs(monsterData) do table.insert(cleanupQueue, p) end
			for _, p in ipairs(cleanupQueue) do cleanupMonster(p) end
		end
	end
end

-- ESP Factories
do
	local function CreateESPLogic(scanFolder: Instance, itemsToTrack: table, isRoomSpecific: boolean)
		local masterList, visibleList, roomConn, descConn = {}, {}, nil, nil
		local function cleanup(model)
			if visibleList[model] then
				Common.TweenInstance(visibleList[model].highlight, true)
				Common.TweenInstance(visibleList[model].billboard, true)
				ActiveESPs[model] = nil
				visibleList[model] = nil
			end
		end
		local function setup(model)
			if visibleList[model] then
				return
			end
			local itemConfig = itemsToTrack[model.Name]
			if not itemConfig then
				return
			end
			local firstPart = model:FindFirstChildWhichIsA("BasePart", true)
			if not firstPart then
				return
			end
			local highlight = Instance.new("Highlight")
			highlight.Parent, highlight.FillColor, highlight.OutlineColor, highlight.DepthMode, highlight.FillTransparency = model, itemConfig.Color, itemConfig.Color, Enum.HighlightDepthMode.AlwaysOnTop, 0.5
			local adornee = model.PrimaryPart or firstPart
			local espText
			if itemConfig.TextGenerator then
				espText = itemConfig.TextGenerator(model)
			else
				espText = itemConfig.Text or model.Name
			end
			local guiElements = Common.CreateBillboardGui({ Parent = adornee, Adornee = adornee, Text = espText, TextColor = itemConfig.Color })
			visibleList[model] = { highlight = highlight, billboard = guiElements.gui }
			ActiveESPs[model] = { adornee = adornee, distanceLabel = guiElements.distanceLabel }
			Common.TweenInstance(highlight, false)
			Common.TweenInstance(guiElements.gui, false)
		end
		local function updateVisibility()
			local currentRoomModel = Common.GetCurrentRoomModel()
			for model, _ in pairs(masterList) do
				if model and model.Parent and currentRoomModel and model:IsDescendantOf(currentRoomModel) then
					setup(model)
				else
					cleanup(model)
				end
			end
		end
		return function(enable: boolean)
			if enable then
				for _, d in ipairs(scanFolder:GetDescendants()) do
					if itemsToTrack[d.Name] and d:IsA("Model") then
						if isRoomSpecific then
							masterList[d] = true
						else
							setup(d)
						end
					end
				end
				descConn = scanFolder.DescendantAdded:Connect(function(d)
					if itemsToTrack[d.Name] and d:IsA("Model") then
						if isRoomSpecific then
							masterList[d] = true
							updateVisibility()
						else
							setup(d)
						end
					end
				end)
				if isRoomSpecific then
					roomConn = Common.RoomChanged:Connect(updateVisibility)
					updateVisibility()
				end
			else
				if roomConn then
					Common.RoomChanged:Disconnect(roomConn)
					roomConn = nil
				end
				if descConn then
					descConn:Disconnect()
					descConn = nil
				end
				for model, _ in pairs(visibleList) do
					cleanup(model)
				end
				masterList, visibleList = {}, {}
			end
		end
	end
	local items = { ["KeyObtain"] = { Color = Color3.fromRGB(255, 255, 0) }, ["Lighter"] = { Color = Color3.fromRGB(255, 165, 0) }, ["Flashlight"] = { Color = Color3.fromRGB(200, 200, 200) }, ["Vitamins"] = { Color = Color3.fromRGB(255, 105, 180) }, ["Bandage"] = { Color = Color3.fromRGB(255, 255, 255) }, ["Lockpicks"] = { Color = Color3.fromRGB(100, 100, 100) }, ["Candle"] = { Color = Color3.fromRGB(255, 250, 205) }, ["Battery"] = { Color = Color3.fromRGB(50, 205, 50) }, ["SkeletonKey"] = { Color = Color3.fromRGB(255, 255, 255), Text = "Skeleton Key" }, ["Crucifix"] = { Color = Color3.fromRGB(255, 165, 0), Text = "CRUCIFIX!!!!!" }, ["Smoothie"] = { Color = Color3.fromRGB(255, 250, 205) } }
	local hidingSpots = { ["Wardrobe"] = { Color = Color3.fromRGB(0, 150, 255) }, ["Locker"] = { Color = Color3.fromRGB(0, 150, 255) } }
	local objectives = { ["LiveHintBook"] = { Color = Color3.fromRGB(148, 0, 211), Text = "Book" }, ["LiveBreakerPolePickup"] = { Color = Color3.fromRGB(150, 150, 150), Text = "Breaker" } }
	local levers = { ["LeverForGate"] = { Color = Color3.fromRGB(128, 128, 128), Text = "Lever" } }
	local goldItems = { ["GoldPile"] = { Color = Color3.fromRGB(255, 255, 0), TextGenerator = function(model)
		return "Gold: " .. tostring(model:GetAttribute("GoldValue") or 0)
	end } }
	Logic.ItemESP = CreateESPLogic(Common.Rooms, items, false)
	Logic.DropsESP = CreateESPLogic(Common.Drops, items, false)
	Logic.ObjectivesESP = CreateESPLogic(Common.Rooms, objectives, true)
	Logic.HidingESP = CreateESPLogic(Common.Rooms, hidingSpots, true)
	Logic.LeverESP = CreateESPLogic(Common.Rooms, levers, true)
	Logic.GoldESP = CreateESPLogic(Common.Rooms, goldItems, false)
end

-- Anti-Screech, Speed, Prompts, FOV, Animation
do
	Logic.AntiScreech = function(enable: boolean)
		local r = Common.RemotesFolder:FindFirstChild(enable and "Screech" or "notscreech")
		if r then
			r.Name = enable and "notscreech" or "Screech"
		end
	end
	local player = Players.LocalPlayer
	local originalSpeed, speedEnabled, currentSpeed, speedConn = 16, false, 16, nil
	local twerkEnabled, twerkAnimTrack = false, nil
	local TWERK_ANIM_ID = "rbxassetid://12874447851"
	local autoInteractEnabled, autoInteractTarget, autoInteractConn = false, "Gold", nil

	local function stopTwerk()
		if twerkAnimTrack then
			twerkAnimTrack:Stop()
			twerkAnimTrack:Destroy()
			twerkAnimTrack = nil
		end
	end

	local function playTwerk()
		stopTwerk()
		local char = player.Character
		if not char then return end
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if not humanoid then return end
		local animator = humanoid:FindFirstChildOfClass("Animator")
		if not animator then return end
		local anim = Instance.new("Animation")
		anim.AnimationId = TWERK_ANIM_ID
		twerkAnimTrack = animator:LoadAnimation(anim)
		twerkAnimTrack.Looped = true
		twerkAnimTrack:Play()
		anim:Destroy()
	end

	local function updateSpeed()
		local char = player.Character
		if not char then return end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if not hum then return end
		hum.WalkSpeed = speedEnabled and currentSpeed or originalSpeed
	end

	local function onCharacter(char)
		local hum = char:WaitForChild("Humanoid")
		originalSpeed = hum.WalkSpeed
		if speedConn then speedConn:Disconnect() end
		speedConn = hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
			if speedEnabled and hum.WalkSpeed ~= currentSpeed then
				hum.WalkSpeed = currentSpeed
			end
		end)
		task.wait(0.1)
		updateSpeed()
		if twerkEnabled then
			playTwerk()
		end
	end

	player.CharacterAdded:Connect(onCharacter)
	player.CharacterRemoving:Connect(stopTwerk)
	if player.Character then onCharacter(player.Character) end

	Logic.SetSpeed = function(enable: boolean)
		speedEnabled = enable
		updateSpeed()
	end
	Logic.SetSpeedValue = function(value: number)
		currentSpeed = value
		if speedEnabled then updateSpeed() end
	end
	Logic.Twerk = function(enable: boolean)
		twerkEnabled = enable
		if enable then
			playTwerk()
		else
			stopTwerk()
		end
	end

	local promptData, promptConns = {}, {}
	local function cleanupPrompt(p)
		if promptData[p] and p and p.Parent then
			p.HoldDuration = promptData[p].originalDuration
			promptData[p] = nil
		end
	end
	local function setupPrompt(p)
		if not p or not p:IsA("ProximityPrompt") or promptData[p] then return end
		promptData[p] = { originalDuration = p.HoldDuration }
		p.HoldDuration = 0
	end
	Logic.InstantPrompts = function(enable: boolean)
		if enable then
			for _, container in ipairs({ Common.Rooms, Common.Drops }) do
				for _, d in ipairs(container:GetDescendants()) do
					if d:IsA("ProximityPrompt") then setupPrompt(d) end
				end
				local conn = container.DescendantAdded:Connect(function(d)
					if d:IsA("ProximityPrompt") then setupPrompt(d) end
				end)
				table.insert(promptConns, conn)
			end
		else
			for _, conn in ipairs(promptConns) do conn:Disconnect() end
			promptConns = {}
			local toClean = {}
			for p in pairs(promptData) do table.insert(toClean, p) end
			for _, p in ipairs(toClean) do cleanupPrompt(p) end
		end
	end

	local clipData, clipConns = {}, {}
	local function cleanupClip(p)
		if clipData[p] and p and p.Parent then
			p.RequiresLineOfSight = clipData[p].originalLineOfSight
			clipData[p] = nil
		end
	end
	local function setupClip(p)
		if not p or not p:IsA("ProximityPrompt") or clipData[p] then return end
		clipData[p] = { originalLineOfSight = p.RequiresLineOfSight }
		p.RequiresLineOfSight = false
	end
	Logic.ClipPrompts = function(enable: boolean)
		if enable then
			for _, container in ipairs({ Common.Rooms, Common.Drops }) do
				for _, d in ipairs(container:GetDescendants()) do
					if d:IsA("ProximityPrompt") then setupClip(d) end
				end
				local conn = container.DescendantAdded:Connect(function(d)
					if d:IsA("ProximityPrompt") then setupClip(d) end
				end)
				table.insert(clipConns, conn)
			end
		else
			for _, conn in ipairs(clipConns) do conn:Disconnect() end
			clipConns = {}
			local toClean = {}
			for p in pairs(clipData) do table.insert(toClean, p) end
			for _, p in ipairs(toClean) do cleanupClip(p) end
		end
	end
	
	local promptReachData, promptReachConns = {}, {}
	local promptReachMultiplier = 1
	local promptReachEnabled = false
	
	local function cleanupReach(p)
		if promptReachData[p] and p then
			p.MaxActivationDistance = promptReachData[p].originalDistance
			promptReachData[p] = nil
		end
	end
	
	local function setupReach(p)
		if not p or not p:IsA("ProximityPrompt") or promptReachData[p] then return end
		promptReachData[p] = { originalDistance = p.MaxActivationDistance }
		if promptReachEnabled then
			p.MaxActivationDistance = p.MaxActivationDistance * promptReachMultiplier
		end
	end
	
	Logic.PromptReach = function(enable: boolean)
		promptReachEnabled = enable
		if enable then
			for _, container in ipairs({ Common.Rooms, Common.Drops }) do
				for _, d in ipairs(container:GetDescendants()) do
					if d:IsA("ProximityPrompt") then setupReach(d) end
				end
				local conn = container.DescendantAdded:Connect(function(d)
					if d:IsA("ProximityPrompt") then setupReach(d) end
				end)
				table.insert(promptReachConns, conn)
			end
		else
			for _, conn in ipairs(promptReachConns) do conn:Disconnect() end
			promptReachConns = {}
			local toClean = {}
			for p in pairs(promptReachData) do
				table.insert(toClean, p)
			end
			for _, p in ipairs(toClean) do cleanupReach(p) end
		end
	end
	
	Logic.SetPromptReachValue = function(value: number)
		promptReachMultiplier = value
		if promptReachEnabled then
			for p, data in pairs(promptReachData) do
				if p and p.Parent then
					p.MaxActivationDistance = data.originalDistance * value
				end
			end
		end
	end

	local allItemNames = { ["KeyObtain"] = true, ["Lighter"] = true, ["Flashlight"] = true, ["Vitamins"] = true, ["Bandage"] = true, ["Lockpicks"] = true, ["Candle"] = true, ["Battery"] = true, ["SkeletonKey"] = true, ["Crucifix"] = true, ["Smoothie"] = true, ["GoldPile"] = true }
	local function onPromptShown(prompt)
		if not (prompt and prompt.Parent and prompt.Parent:IsA("Model")) then return end

		local modelName = prompt.Parent.Name
		local shouldTrigger = false

		if autoInteractTarget == "All Items" then
			if allItemNames[modelName] then shouldTrigger = true end
		elseif autoInteractTarget == "Keys" then
			if modelName == "KeyObtain" or modelName == "SkeletonKey" then shouldTrigger = true end
		elseif autoInteractTarget == "Gold" then
			if modelName == "GoldPile" then shouldTrigger = true end
		end

		if shouldTrigger then
			prompt:InputHoldBegin()
		end
	end
	Logic.SetAutoInteract = function(enable)
		autoInteractEnabled = enable
		if enable then
			if not autoInteractConn then
				autoInteractConn = ProximityPromptService.PromptShown:Connect(onPromptShown)
			end
		else
			if autoInteractConn then
				autoInteractConn:Disconnect()
				autoInteractConn = nil
			end
		end
	end
	Logic.SetAutoInteractTarget = function(target)
		autoInteractTarget = target
	end


end

-- room and ESP distance tracker
task.spawn(function()
	local function getCurrentRoom(player)
		Common.CurrentRoom = game.Players.LocalPlayer:GetAttribute("CurrentRoom")
	end
	

	RunService.RenderStepped:Connect(function()
		local playerChar = Players.LocalPlayer.Character
		if not playerChar or not playerChar.PrimaryPart then return end
		local playerPos = playerChar.PrimaryPart.Position
		for espKey, esp in pairs(ActiveESPs) do
			if esp.adornee and esp.adornee.Parent then
				local adorneePos
				if esp.adornee:IsA("BasePart") then
					adorneePos = esp.adornee.Position
				elseif esp.adornee:IsA("Model") then
					adorneePos = esp.adornee:GetPivot().Position
				end

				if adorneePos then
					local dist = math.round((playerPos - adorneePos).Magnitude)
					esp.distanceLabel.Text = "[" .. dist .. " studs]"
				end
			end
		end
	end)
end)

debugNotify("initialized Logic")


----------------------------------
--------------- UI ---------------
----------------------------------

-- Configure Obsidian
Obsidian.NotifyOnError = true
Obsidian.ForceCheckbox = false
Obsidian.ShowToggleFrameInKeybinds = true
Obsidian:OnUnload(function()
	print(SCRIPT_ID .. ": Unloaded!")
end)
debugNotify("configured Obsidian")


-- Window
local Window = Obsidian:CreateWindow({ Title = "cooliopoolio47 hub", Footer = SCRIPT_ID, NotifySide = "Right", ShowCustomCursor = true, Center = true, AutoShow = true, ToggleKeybind = Enum.KeyCode.RightAlt })
debugNotify("created Window")


-- Tabs
local Tabs = { Main = Window:AddTab("Main", "user"), Visual = Window:AddTab("Visual", "eye"), Floor = Window:AddTab("Floor", "circle-question-mark"), UI_Settings = Window:AddTab("UI Settings", "settings") }
debugNotify("created Tabs")


-- Tabs.Main
do
	local AntiEntityGroupbox = Tabs.Main:AddLeftGroupbox("Anti-Entity", "eye")
	AntiEntityGroupbox:AddToggle("AntiScreech", { Text = "Anti-Screech", Default = false, Callback = function(v)
		Logic.AntiScreech(v)
	end })
	AntiEntityGroupbox:AddToggle("MonsterAlert", { Text = "Monster Alert", Default = false, Callback = function(v)
		Logic.SetMonsterAlert(v)
	end })
	local PlayerGroupbox = Tabs.Main:AddLeftGroupbox("Player", "user")
	PlayerGroupbox:AddToggle("EnableSpeed", { Text = "Enable Speed", Default = false, Callback = function(v)
		Logic.SetSpeed(v)
	end })
	PlayerGroupbox:AddSlider("SpeedValue", { Text = "WalkSpeed", Default = 16, Min = 2, Max = 25, Rounding = 0, Callback = function(v)
		Logic.SetSpeedValue(v)
	end })
	PlayerGroupbox:AddSlider("PromptReachValue", { Text = "Reach Multiplier (markiplier)", Default = 1, Min = 0.5, Max = 2, Rounding = 1, Callback = function(v)
		Logic.SetPromptReachValue(v)
	end })
	PlayerGroupbox:AddToggle("PromptReach", { Text = "Prompt Reach", Default = false, Callback = function(v)
		Logic.PromptReach(v)
	end })
	PlayerGroupbox:AddToggle("InstantPrompts", { Text = "Instant Prompts", Default = false, Callback = function(v)
		Logic.InstantPrompts(v)
	end })
	PlayerGroupbox:AddToggle("ClipPrompts", { Text = "Clip Prompts", Default = false, Callback = function(v)
		Logic.ClipPrompts(v)
	end })
	PlayerGroupbox:AddToggle("Twerk", { Text = "Twerk", Default = false, Callback = function(v)
		Logic.Twerk(v)
	end })
	PlayerGroupbox:AddToggle("AutoInteract", { Text = "Auto Interact", Default = false, Callback = function(v)
		Logic.SetAutoInteract(v)
	end })
	PlayerGroupbox:AddDropdown("AutoInteractTarget", { Values = { "Gold", "Keys", "All Items" }, Default = "Gold", Text = "Interact Target", Callback = function(v)
		Logic.SetAutoInteractTarget(v)
	end })
end
debugNotify("created Tabs.Main")


-- Tabs.Floor
do
	local BackdoorGroupbox = Tabs.Floor:AddLeftGroupbox("Backdoor", "circle-question-mark")
end
debugNotify("created Tabs.Floor")


-- Tabs.Visual
do
	local LightingGroupbox = Tabs.Visual:AddLeftGroupbox("Lighting", "zap")
	LightingGroupbox:AddToggle("Fullbright", { Text = "Fullbright", Default = false, Callback = function(v)
		Logic.Fullbright(v)
	end })
	local ESPGroupbox = Tabs.Visual:AddLeftGroupbox("ESP", "eye")
	ESPGroupbox:AddToggle("DoorESP", { Text = "Door ESP", Default = false, Callback = function(v)
		Logic.DoorESP(v)
	end })
	ESPGroupbox:AddToggle("MonsterESP", { Text = "Monster ESP", Default = false, Callback = function(v)
		Logic.MonsterESP(v)
	end })
	ESPGroupbox:AddToggle("ItemESP", { Text = "Item ESP", Default = false, Callback = function(v)
		Logic.ItemESP(v)
	end })
	ESPGroupbox:AddToggle("DropsESP", { Text = "Drops ESP", Default = false, Callback = function(v)
		Logic.DropsESP(v)
	end })
	ESPGroupbox:AddToggle("GoldESP", { Text = "Gold ESP", Default = false, Callback = function(v)
		Logic.GoldESP(v)
	end })
	ESPGroupbox:AddToggle("HidingESP", { Text = "Hiding Spot ESP", Default = false, Callback = function(v)
		Logic.HidingESP(v)
	end })
	ESPGroupbox:AddToggle("ObjectivesESP", { Text = "Objective ESP", Default = false, Callback = function(v)
		Logic.ObjectivesESP(v)
	end })
	ESPGroupbox:AddToggle("LeverESP", { Text = "Lever ESP", Default = false, Callback = function(v)
		Logic.LeverESP(v)
	end })
end
debugNotify("created Tabs.Visual")


-- Tabs.UI_Settings
do
	local MenuGroup = Tabs.UI_Settings:AddLeftGroupbox("Menu", "wrench")
	MenuGroup:AddToggle("KeybindMenuOpen", { Default = Obsidian.KeybindFrame.Visible, Text = "Open Keybind Menu", Callback = function(v)
		Obsidian.KeybindFrame.Visible = v
	end })
	MenuGroup:AddToggle("ShowCustomCursor", { Text = "Custom Cursor", Default = true, Callback = function(v)
		Obsidian.ShowCustomCursor = v
	end })
	MenuGroup:AddDropdown("NotificationSide", { Values = { "Left", "Right" }, Default = "Right", Text = "Notification Side", Callback = function(v)
		Obsidian:SetNotifySide(v)
	end })
	MenuGroup:AddDropdown("DPIDropdown", { Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" }, Default = "100%", Text = "DPI Scale", Callback = function(v)
		v = v:gsub("%%", "")
		Obsidian:SetDPIScale(tonumber(v))
	end })
	MenuGroup:AddDivider()
	MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })
	Obsidian.ToggleKeybind = Obsidian.Options.MenuKeybind
	MenuGroup:AddButton("Unload", function()
		Obsidian:Unload()
	end)
end
debugNotify("created Tabs.UI_Settings")


-- SaveManager
SaveManager:SetLibrary(Obsidian)
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
SaveManager:SetFolder(SCRIPT_HUB_NAME .. "/" .. SCRIPT_HUB_GAME)
SaveManager:SetSubFolder(SCRIPT_HUB_PLACE)
SaveManager:BuildConfigSection(Tabs.UI_Settings)
SaveManager:LoadAutoloadConfig()
debugNotify("initialized SaveManager")


-- Done!
debugNotify("loading complete!")

task.wait(10)
print("freakbob is going to get you")
